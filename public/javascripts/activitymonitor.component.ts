/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import {
  Component, OnInit, ViewChild, OnDestroy, AfterViewInit,
  ViewChildren, ChangeDetectorRef, ChangeDetectionStrategy, Input, Output, EventEmitter
} from '@angular/core';
import { DropDownListComponent } from '@progress/kendo-angular-dropdowns';
import {
  Activitymonitorcolumn, IEquipmentRequest,
  EquipmentDemandOrder, EquipmentRequest, EquipmentRequestQueryModel, MateoPatchQueryModel
} from 'src/app/modules/activitymonitor/models/activitymonitor/activitymonitor';
import { process } from '@progress/kendo-data-query';
import { GridComponent, DataStateChangeEvent, ColumnComponent } from '@progress/kendo-angular-grid';
import { PageChangeEvent } from '@progress/kendo-angular-grid';
import { FMPConstant } from 'src/Constants/constant';
import { UserprofileService } from 'src/app/base/userprofile/userprofile.service';
import * as $ from 'jquery';
import { ActivityMonitorViewModel } from 'src/app/modules/activitymonitor/models/activitymonitor/activitymonitor';
import { Subscription } from 'rxjs/Subscription';
import { SplitterPaneComponent } from 'node_modules/@progress/kendo-angular-layout';
// import { SideNavOverlayService } from 'src/app/sharedcomponents/sidenav-overlay/sidenav-overlay.service';
import { GridConfigModel, GridPagerConfigModel } from 'src/app/sharedcomponents/models/sharedmodels';
import { UserProfileViewModel, SavedPreference, Profile } from 'src/app/base/models/userprofile';
import { ActivityMonitorSearchFilterModel } from 'src/app/modules/activitymonitor/models/searchactivitymonitor/searchactivitymonitor';
import { ExcelExportData } from '@progress/kendo-angular-excel-export';
import { SideNavViewModel, IActiveLayout, Layout } from 'src/app/sharedcomponents/models/sidenav-overlay';
import { ActivitysearchService } from 'src/app/modules/activitymonitor/activitymonitor/activitysearch/activitysearch.service';
import { RowClassArgs } from '@progress/kendo-angular-grid';
import { ColumnOptionsService } from 'src/app/sharedcomponents/columnOptions/columnoptions.service';
import { FMPHelper, UnitOfMeasurements } from 'src/Constants/helpers';
import * as LO from 'lodash';
import { LoaderService } from 'src/app/base/loader/loader.service';
import { BaseComponent } from 'src/app/base/component/base/base.component';
import { LoggerService } from 'src/app/base/service/logger.service';
import { ExpandCollapseGroupsComponent } from 'src/app/sharedcomponents/expand-collapse-groups/expand-collapse-groups.component';
import {
  TrafficLightPriorityClass, TrafficLightStatus, ActivityMonitorConstant, TrafficLightHelper, exportExcelField, ActvityMonitorFilterValues, PatchJsonFields, CommentsPopupConstant
} from 'src/app/modules/activitymonitor/activitymonitor/activityMonitorHelper';
import { Polling } from 'src/app/base/models/polling';
import { DateRangeCellFilterComponent } from 'src/app/sharedcomponents/date-range-cell-filter/date-range-cell-filter.component';
import { ActivitymonitorService } from '../activity-monitor.service';
import { TcologhistoryService } from '../tcologhistory/tcologhistory.service';
import { EquipmentDemandOrderRecord, CommentPopupViewModel, EdoEnrichment, EDOPriority } from 'src/app/modules/activitymonitor/models/activitymonitor/activitymonitorgrid';
import { ComponentInteractionService } from 'src/app/base/service/component-interaction.service';
import { IEquipmentDemandOrder } from 'src/app/modules/activitymonitor/models/activitymonitor/activitymonitor';
import { EdoEnrichmentService } from './edoenrichment.service';
import { ActivitymateopatchService } from './activitymateopatch.service';
import { s } from '@angular/core/src/render3';

@Component({
  selector: 'app-fmp-activity-monitor-grid',
  templateUrl: './activitymonitor.component.html',
  styleUrls: ['./activitymonitor.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})

export class ActivityMonitorGridComponent extends BaseComponent implements OnInit, AfterViewInit, OnDestroy {

  @Input() viewModel: ActivityMonitorViewModel;
  @Input() sideNavModel: SideNavViewModel;
  gridModel: GridConfigModel;
  private equipmentRequestApiSubscription: Subscription;
  private equipmentRequestTCOApiSubscription: Subscription;
  private equipmentRequestErrorSubscription: Subscription;
  private userPreferenceSubscription: Subscription;
  private searchClickSubsciption: Subscription;
  private layoutChangeSubscription: Subscription;
  private acticityMonitorSubscription: Subscription;
  private patchTLMShipDateApiSubscription: Subscription;
  private patchErrorSubscription: Subscription;
  private patchNextShipDateApiSubscription: Subscription;
  private patchTLMAcualShipDateApiSubscription: Subscription;
  private patchPlannedShipDateApiSubscription: Subscription;
  private patchPriorityApiSubscription: Subscription;
  private patchCommentApiSubscription: Subscription;
  private patchCommentErrorSubscription: Subscription;

  @ViewChild('activitymonitorgrid') activitymonitorgrid: GridComponent;
  @ViewChild('splitterPane') splitterPane: SplitterPaneComponent;
  @ViewChild(ExpandCollapseGroupsComponent) expandCollapseGroups: ExpandCollapseGroupsComponent;
  @ViewChild('acivityMonitorLayoutDropdown') layoutDropdown: DropDownListComponent;
  @ViewChildren(DateRangeCellFilterComponent) gridDateFilters: DateRangeCellFilterComponent[];

  //#region Local variable

  GridColumnDetails: Activitymonitorcolumn;
  public aggregates: any[] = [{ field: 'Counter', aggregate: 'sum' }];
  public tcoHyperlinkURL = FMPHelper.ApplicationSettings.tcoLinkUrl;
  public gridHeight: number;
  public excelColumns: ColumnComponent[] = [];
  public pdfColumns: ColumnComponent[] = [];
  public totalWidth = 0;
  // public missedCheckStatusField: string;
  // public missedCheckStatusFieldHier: string;
  // public missedCheckStatusFieldHierFlag: boolean;
  public index: number;
  public locking = false;
  get todayDate(): Date {
    return FMPHelper.CurrentUTCDate;
  }
  //#endregion

  //#region filter data
  // The below variables are set to bind values as dat sources fo Grid Inline filters
  // The values are sorted to display them in alphabetical sequence
  public tCOStatus;
  public jobStatus;
  public priorityList;
  public eDOToolStatus;
  public movementType;
  public productGroupStatus;
  public productLineStatus;
  //#endregion
  public userProfileViewModel: UserProfileViewModel;

  constructor(private _activitymonitorService: ActivitymonitorService,
    private _userProfileService: UserprofileService,
    // private _sideNavService: SideNavOverlayService,
    private _activitysearchService: ActivitysearchService,
    private _columnOptionsService: ColumnOptionsService,
    private _loaderService: LoaderService,
    // private _kendoFilterService: FilterService,
    _loggerService: LoggerService,
    private changeDetector: ChangeDetectorRef,
    private _tcoLogService: TcologhistoryService,
    private _componentInteractionService: ComponentInteractionService,
    private _edoEnrichmentService: EdoEnrichmentService,
    private _mateoPatch: ActivitymateopatchService,
  ) {
    super('ActivityMonitorComponent', _loggerService);
    this.WriteDebugLog('ActiChangeDetectorRefnent => constructor');
    this.tCOStatus = ActvityMonitorFilterValues.TCOStatus;
    this.jobStatus = ActvityMonitorFilterValues.JobStatus;
    this.priorityList = ActvityMonitorFilterValues.Priority;
    this.eDOToolStatus = ActvityMonitorFilterValues.EDOToolStatus;
    this.movementType = ActvityMonitorFilterValues.MovementType;
    this.productGroupStatus = ActvityMonitorFilterValues.ProductGroupStatus;
    this.productLineStatus = ActvityMonitorFilterValues.ProductLineStatus;

    this.viewModel = new ActivityMonitorViewModel(this._activitymonitorService.dataModel);
    this.viewModel.searchDataModel = this._activitysearchService.dataModel;
    this.userProfileViewModel = new UserProfileViewModel(this._userProfileService.dataModel);

    this.initGridModel();

    this.viewModel.searchModel = new ActivityMonitorSearchFilterModel();
    this.userProfileViewModel = new UserProfileViewModel(this._userProfileService.dataModel);

    this.sideNavModel = new SideNavViewModel(this._columnOptionsService.dataModel);
    this.sideNavModel.application = FMPConstant.activityMonitor;
    this.sideNavModel.panelHeader = FMPConstant.activityMonitorPanel;

    this.GridColumnDetails = new Activitymonitorcolumn();
    this.allData = this.allData.bind(this);
  }

  /**
   * This method is used to initialize the grid model properties
   * for ActivityMonitor grid related to Pagination, Grouping, Sorting
   * Filtering, Column reordering and Date fields in grid.
   * @memberof ActivityMonitorGridComponent
   */
  initGridModel() {
    this.WriteDebugLog('ActivityMonitorComponent => initGridModel');
    this.gridModel = new GridConfigModel();
    this.gridModel.skip = 0;
    this.gridModel.take = 20;
    this.gridModel.GroupSettings = [];

    this.gridModel.expandCounter = 1;
    this.gridModel.defaultPageSize = FMPConstant.defaultPageSize;
    this.gridModel.isPagingEnabled = true;
    this.gridModel.sorting = { mode: 'multiple' };
    this.gridModel.selectableSettings = { checkboxOnly: true, mode: 'multiple' };
    this.gridModel.isFilteringEnabled = true;
    this.gridModel.isGroupingEnabled = true;
    this.gridModel.isColumnReOrderEnabled = true;
    this.gridModel.isColumnResizingEnabled = true;

    this.gridModel.pager = new GridPagerConfigModel();
    this.gridModel.pager.buttonCount = FMPConstant.btnCount;
    this.gridModel.pager.pageSizeOptions = FMPConstant.pagingsize;
    this.gridModel.GridDateFields = ActivityMonitorConstant.activityMonitorGridDateFields;
  }

  /**
   *
   *
   * @memberof ActivityMonitorGridComponent
   */
  ngOnInit() {
    this.WriteDebugLog('ActivityMonitorComponent => ngOnInit');
    // reset the exisiting data records
    this.viewModel.data.allEquipmentDOData = [];
    this._edoEnrichmentService.isEnrihmentDataLoaded = false;
    // This subscription is used to handle the data recieved from EquipmentRequestAPI based on Site Selections
    // It deals with the request triggered on page load and the other for Search based on job# and date range
    // We pass list of TCO Status to api - all except CREATED, based on which data is fetched.
    this.equipmentRequestApiSubscription = this._activitymonitorService.equipmentRequestsApiObservable.subscribe
      (data => {
        
        this.WriteDebugLog('Data Received from EquipmentRequest API');
        // The data received from EquipmentRequestAPI is at EDP level
        // we display the records on grid at EDO level so we need to transform the data using transformEquipmentResponseData
        const transformedData: EquipmentDemandOrderRecord[] = this.transformEquipmentResponseData(data.items);
        // We keep appending the data to List rather than re initilizing
        // As we make multiple calls to API for each site selected, thus we kepp appending the data received for each site to the result set
        this.viewModel.data.allEquipmentDOData = [...this.viewModel.data.allEquipmentDOData, ...transformedData];
        // Create a copy of the dataset
        this.viewModel.activityMonitorGridData = this.viewModel.data.allEquipmentDOData.slice();
        console.log('data for me: ', this.viewModel);
        // console.log('data for me: ', JSON.stringify(this.viewModel.activityMonitorGridData));
        // Update the grid data based on Grid State
        this.processActivityMonitorData();
      }, error => this.WriteErrorLog('Exception on fetching EquipmentRequest API data', error));

    // This subscription deal with the data received from API When the user searches data based on TCO#
    this.equipmentRequestTCOApiSubscription = this._activitymonitorService.equipmentRequestsTCOApiObservable.subscribe
      (data => {
        this.WriteDebugLog('Data Received from EquipmentRequest TCO API');
        const transformedData: EquipmentDemandOrderRecord[] = this.transformEquipmentResponseData([data]);
        // We keep appending the data to List rather than re initilizing
        // As we make multiple calls to API for each site selected, thus we kepp appending the data received for each site to the result set
        this.viewModel.data.allEquipmentDOData = [...this.viewModel.data.allEquipmentDOData, ...transformedData];
        // Create a copy of the dataset
        this.viewModel.activityMonitorGridData = this.viewModel.data.allEquipmentDOData.slice();
        // Update the grid data based on Grid State
        this.processActivityMonitorData();
      }, error => this.WriteErrorLog('Exception on fetching EquipmentRequest API data', error));
    // If we get any error in API calls then the error subscription is hit
    this.equipmentRequestErrorSubscription = this._activitymonitorService.equipmentRequestsErrorObservable.subscribe
      (errordata => {
        this.WriteErrorLog('Exception on fetching EquipmentRequest API data', errordata);
        // if (this.viewModel.searchModel.isAutoRefreshRequest) {
        //   this.ToasterServiceInstace.ShowError('Refresh Failed. Please try again later.', 'Refresh Failed');
        //   this.viewModel.searchModel.isAutoRefreshRequest = false;
        // }
        this.onDataLoadComplete();
      }, error => this.WriteErrorLog('Exception on handling Error on EquipmentRequest API data', error));

    // This subscription is triggered when user changes the selected Layout
    // it rebinds the Groups, Filters and Sorting based on the selected layout
    this.layoutChangeSubscription = this._columnOptionsService.layoutChangeObservable.subscribe(lay => {
      this.WriteDebugLog('ActivityMonitorComponent => layoutChangeSubscription triggered.');
      if (lay && !this.viewModel.isColumnOptionsOpening) {
        this.sideNavModel.selectedLayout = lay;
        this.gridModel.GroupSettings = lay.group ? lay.group.slice() : null;
        this.gridModel.SortSettings = lay.sort ? lay.sort.slice() : null;
        this.gridModel.FilterSettings = lay.filter ? FMPHelper.CloneJSONObject(lay.filter) : null;
        // This method is used to manage grid columns and other grid settings based on the current layout
        this.resetColumnsOrderBasedonLayout();
        this._activitymonitorService.getPdfGridHeader(this.pdfColumns);
      }
      this.viewModel.isColumnOptionsOpening = false;
    }, error => this.WriteErrorLog('Error while changing layouts', error));

    // Subscriptions for PATCH calls
    this.patchTLMShipDateApiSubscription = this._mateoPatch.patchTLMShipDateApiObservable.subscribe(data => {
      this.ToasterServiceInstace.ShowSuccess('TLM Ship Date updated successfully');
    });
    this.patchNextShipDateApiSubscription = this._mateoPatch.patchNextShipDateApiObservable.subscribe(data => {
      this.ToasterServiceInstace.ShowSuccess('Next Ship Date updated successfully');
    });

    this.patchTLMAcualShipDateApiSubscription = this._mateoPatch.patchTlmActualShipDateApiObservable.subscribe(data => {
      this.ToasterServiceInstace.ShowSuccess('TLM Actual Ship Date updated successfully');
    });

    this.patchPlannedShipDateApiSubscription = this._mateoPatch.patchPlanShipDateApiObservable.subscribe(data => {
      this.ToasterServiceInstace.ShowSuccess('Planned Ship Date updated successfully');
    });

    this.patchCommentApiSubscription = this._mateoPatch.patchCommentApiObservable.subscribe(data => {
      this.ToasterServiceInstace.ShowSuccess(`${data} updated successfully`);
    });

    this.patchPriorityApiSubscription = this._mateoPatch.patchTcoPriorityApiObservable.subscribe(data => {
      this.ToasterServiceInstace.ShowSuccess('TCO Priority updated successfully');
    });

    // Patch Error Subscriptions
    this.patchErrorSubscription = this._mateoPatch.patchErrorObservable.subscribe(error => {

      const updateFailed = this._mateoPatch.PatchMateoURLCollection.filter(requests => requests.QueueItem.HasFailed === true);
      updateFailed.forEach(request => {
        const index = this._mateoPatch.PatchMateoURLCollection.findIndex(i => i.key === request.key);
        switch (request.field) {
          case PatchJsonFields.TLMShipDatePatch.tlmShipDate:
            this._mateoPatch.revertTLMShipDate(this.viewModel.activityMonitorGridData, request, index);
            break;

          case PatchJsonFields.NextShipDatePatch.nextShipDate:
            this._mateoPatch.revertNextShipDate(this.viewModel.activityMonitorGridData, request, index);
            break;

          case PatchJsonFields.TLMActualShipDatePatch.tlmActualShipDate:
            this._mateoPatch.revertTLMActualShipDate(this.viewModel.activityMonitorGridData, request, index);
            break;

          case PatchJsonFields.PlanShipDatePatch.planShipDate:
            this._mateoPatch.revertPlanShipDate(this.viewModel.activityMonitorGridData, request, index);
            break;

          case PatchJsonFields.PriorityPatch.priority:
          this._mateoPatch.revertTCOPriority(this.viewModel.activityMonitorGridData, request, index);
            break;
          case CommentsPopupConstant.maintenanceOperationsColumnName:
            this.ToasterServiceInstace.ShowError('Comment for Maintenance & Operations failed');
            this._mateoPatch.PatchMateoURLCollection.splice(index, 1);
            break;
          case CommentsPopupConstant.tcoCommentColumnName:
            this.ToasterServiceInstace.ShowError('Comment for TCO Operations failed');
            this._mateoPatch.PatchMateoURLCollection.splice(index, 1);
            break;
          case CommentsPopupConstant.shippingInstructionsColumnName:
            this.ToasterServiceInstace.ShowError('Comment for Shipping Instructions failed');
            this._mateoPatch.PatchMateoURLCollection.splice(index, 1);
            break;
        }

        this.changeDetector.detectChanges();
      });
    });


    if (this.userProfileViewModel.data.user
      && this.userProfileViewModel.data.user.seletedRole
      && this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations
      && this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations.length > 0) {
      // Fetch layouts for current user
      this.getActivityMonitorLayouts();
    }

    // Fetch the User Preferences saved in Mongo Database, this user preferences includes UOM preferences for Temperature and Pressure
    this.userPreferenceSubscription = this._userProfileService.userPreferencesObservable.subscribe((userPreference) => {
      if (userPreference && userPreference.UOMDetails && this.viewModel.data.allEquipmentDOData) {
        // iterate through the EDO and convert Temperature and Pressure values
        for (const equipmenDO of this.viewModel.data.allEquipmentDOData) {
          try {
            // Convert Temperature values based on the user preferences
            this.convertTemperatureData(equipmenDO, userPreference);
            // Convert Pressure values based on the user preferences
            this.convertPressureData(equipmenDO, userPreference);
            this.changeDetector.markForCheck();
          } catch (ex) {
            // this.WriteErrorLog(`Error during unit conversion for ${equipmenDO.ed}`, ex);
          }
        }
      }
    }, err => this.WriteErrorLog('Activity Monitor - User Preference Subscription Error.', err));
    // This method triggers the Search, it will display a loader and then trigger FetchActivityMonitorData method
    // Fetch ActivityMonitorData will check if user has set any search params else it will load data based on site selections
    this.ActivityMonitorSearchClickSubscription();
  }

  /**
   *  This method is used to Convert the values of Temperature columns into user preferred UOM
   *
   * @param {EquipmentDemandOrderRecord} dataItem
   * @param {SavedPreference} userPreference
   * @memberof ActivityMonitorGridComponent
   */
  public convertTemperatureData(dataItem: EquipmentDemandOrderRecord, userPreference: SavedPreference) {
    // Convert the MAx BH Circ Temperature into the user Preferred value
    if (dataItem.maxBHCircTemp) {
      dataItem.maxBHCircTempConverted = FMPHelper.convertTemparature(
        UnitOfMeasurements.Default.Temprature,
        userPreference.UOMDetails.Temprature,
        dataItem.maxBHCircTemp);
    }

    // Convert the MAx BH Static Temperature into the user Preferred value
    if (dataItem.maxBHStaticTemp) {
      dataItem.maxBHStaticTempConverted = FMPHelper.convertTemparature(
        UnitOfMeasurements.Default.Temprature,
        userPreference.UOMDetails.Temprature,
        dataItem.maxBHStaticTemp);
    }
  }

  /**
   * This method is used to Convert the values of Pressure columns into user preferred UOM
   *
   * @param {EquipmentDemandOrderRecord} dataItem
   * @param {SavedPreference} userPreference
   * @memberof ActivityMonitorGridComponent
   */
  public convertPressureData(dataItem: EquipmentDemandOrderRecord, userPreference: SavedPreference) {
    if (dataItem.maxBHPressure) {
      dataItem.maxBHPressureConverted = FMPHelper.convertPressure(
        UnitOfMeasurements.Default.Pressure,
        userPreference.UOMDetails.Pressure,
        dataItem.maxBHPressure);
    }
  }

  //#region Fetch Activity Monitor data from API based on Sites selected

  /**
   * Check if there are any existing requests in queue, if any requests are
   *  in-progress i.e. other than succeeded or failed then abort and remove the existing requests from Queue
   *
   * @memberof ActivityMonitorGridComponent
   */
  fetchActivityMonitorData() {
    this._edoEnrichmentService.isEnrihmentDataLoaded = false;
    this.WriteDebugLog('ActivitymonitorComponent => fetchActivityMonitorData');
    this._loaderService.showSpinner();
    // reset page number to 0
    this.gridModel.skip = 0;
    // Before triggering another request to Mateo, clear any existing in-progress requests
    // (they are identified using HasToProcess getter property )
    if (this.viewModel.searchDataModel.MateoURLCollection && this.viewModel.searchDataModel.MateoURLCollection.length > 0) {
      Polling.AbortQueueItems(this.viewModel.searchDataModel.MateoURLCollection
        .filter(q => q.QueueItem && q.QueueItem.HasToProcess).map(q => q.QueueItem));
    }
    // reset data and all queues for search
    this.viewModel.searchDataModel.MateoURLCollection = [];
    this.viewModel.data.allEquipmentDOData = [];
    this.viewModel.activityMonitorGridData = [];
    this.viewModel.activityMonitorBound = null;
    this._tcoLogService.dataModel.allTCOLogHistory.clear();

    let isSearch = false;
    // If any TCO's or Jobs are selected in Search Panel then mark isSearch flag to true
    // isSearch enables pulling data from API based on the user defined parmeters
    if (this.viewModel.searchModel && ((this.viewModel.searchModel.SelectedJobs && this.viewModel.searchModel.SelectedJobs.length > 0)
      || (this.viewModel.searchModel.TCO && this.viewModel.searchModel.TCO.length > 0))) {
      isSearch = true;
    }
    // Fetch data based on the JOb# or Sites selected
    const querySearchList = this.createEquipmentQueryAPIList(isSearch);
    if (querySearchList && querySearchList.length > 0) {
      querySearchList.forEach(query => {
        query = this._activitymonitorService.getEquipmentQueryData(query);
        this.viewModel.searchDataModel.MateoURLCollection.push(query);
      });
    }

    // Search data based  on  the TCO# selected
    const tcoSearchList = this.createEquipmentTCOAPIList();
    if (tcoSearchList && tcoSearchList.length > 0) {
      tcoSearchList.forEach(query => {
        query = this._activitymonitorService.getEquipmentTCOData(query);
        this.viewModel.searchDataModel.MateoURLCollection.push(query);
      });
    }
  }


  /**
   * This method generates the API Request for EquipmentRequestAPI
   * It has two parts,
   *   - If user has selected any Job Numbers then it will search data based on Job#, From-To Date, Site and Segment.
   *     We also pass the Status list for TCO#, it includes all statues except Created.
   *   - If user has not hit Search then it created a request based on the Sites selected, From-To Dates and TCO status list except Created.
   *     In the second case the Job list is passed as null
   * @param {boolean} isSearch
   * @returns {EquipmentRequestQueryModel[]}
   * @memberof ActivityMonitorGridComponent
   */
  createEquipmentQueryAPIList(isSearch: boolean): EquipmentRequestQueryModel[] {
    const queryList: EquipmentRequestQueryModel[] = [];

    if (this.userProfileViewModel.data.user
      && this.userProfileViewModel.data.user.seletedRole
      && this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations
      && this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations.length > 0) {
      // code for new job search
      if (this.viewModel.searchModel && this.viewModel.searchModel.SelectedJobs && this.viewModel.searchModel.SelectedJobs.length > 0) {
        this.viewModel.searchModel.SelectedJobs.forEach(job => {
          job.siteNames.forEach(site => {
            const queryModel: EquipmentRequestQueryModel = new EquipmentRequestQueryModel();
            const siteProfile = this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations.
              find(profile => profile.workLocation === site);
            queryModel.DateRangeSearchFrom = this.viewModel.searchModel.DateRangeSearchFrom;
            queryModel.DateRangeSearchTo = this.viewModel.searchModel.DateRangeSearchTo;
            queryModel.Job = job;
            queryModel.Site = new Profile(null);
            queryModel.pageSize = 70;
            queryModel.pageNumber = 1;
            if (siteProfile) {
              queryModel.Site.segment = siteProfile.segment;
            } else {
              queryModel.Site.segment = '';
            }
            queryModel.Site.workLocation = site;
            queryModel.TCO_Status = [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
            queryList.push(queryModel);
          });
        });
      } else if (!isSearch) {
        this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations.forEach(site => {
          const queryModel: EquipmentRequestQueryModel = new EquipmentRequestQueryModel();
          queryModel.DateRangeSearchFrom = this.viewModel.searchModel.DateRangeSearchFrom;
          queryModel.DateRangeSearchTo = this.viewModel.searchModel.DateRangeSearchTo;
          queryModel.Job = null;
          queryModel.Site = site;
          queryModel.TCO_Status = [1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15];
          queryModel.pageSize = 70;
          queryModel.pageNumber = 1;
          queryList.push(queryModel);

          // For TCO status cancelled and shipped we are taking only 14 days date from to date.

          const queryModelWithShipAndCancel: EquipmentRequestQueryModel = new EquipmentRequestQueryModel();
          queryModelWithShipAndCancel.DateRangeSearchTo = this.viewModel.searchModel.DateRangeSearchTo;
          queryModelWithShipAndCancel.Job = null;
          queryModelWithShipAndCancel.Site = site;
          queryModelWithShipAndCancel.TCO_Status = [2, 14];
          const diffDays = Math.ceil((Math.abs(new Date(this.viewModel.searchModel.DateRangeSearchTo).getTime() -
            new Date(this.viewModel.searchModel.DateRangeSearchFrom).getTime())) / (1000 * 3600 * 24));
          if (diffDays > 14) {
            this.viewModel.FromDate = new Date();
            // we are subtracting DateRangeSearchTo-14 to find 2 week data on grid
            this.viewModel.FromDate.setDate(this.viewModel.searchModel.DateRangeSearchTo.getDate() - 14);
            queryModelWithShipAndCancel.DateRangeSearchFrom = this.viewModel.FromDate;
          } else {
            queryModelWithShipAndCancel.DateRangeSearchFrom = this.viewModel.searchModel.DateRangeSearchFrom;
          }
          queryList.push(queryModelWithShipAndCancel);
        });
      }
    }

    return queryList;
  }

  /**
   * This method creates a request for EquipmentRequestAPI for each TCO# selected by user in Search panel
   *
   * @returns {EquipmentRequestQueryModel[]}
   * @memberof ActivityMonitorGridComponent
   */
  createEquipmentTCOAPIList(): EquipmentRequestQueryModel[] {
    const queryList: EquipmentRequestQueryModel[] = [];

    if (this.userProfileViewModel.data.user
      && this.userProfileViewModel.data.user.seletedRole
      && this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations
      && this.userProfileViewModel.data.user.seletedRole.seletedWorkLocations.length > 0) {
      if (this.viewModel.searchModel
        && this.viewModel.searchModel.TCO
        && this.viewModel.searchModel.TCO.length) {
        this.viewModel.searchModel.TCO.forEach(tco => {
          const queryModel: EquipmentRequestQueryModel = new EquipmentRequestQueryModel();
          queryModel.TCONumber = String(tco);
          queryList.push(queryModel);
        });
      }
    }

    return queryList;
  }
  //#endregion

  //#region Transform EquipmentRequest API Response into Grid required format
  /**
   * This method is used to transform the EDP level data received from API into EDO level
   * the method returns the list of EDO's that are then binded to Activity Monitor grid
   * @param {IEquipmentRequest[]} data
   * @returns {EquipmentDemandOrderRecord[]}
   * @memberof ActivityMonitorGridComponent
   */
  transformEquipmentResponseData(data: IEquipmentRequest[]): EquipmentDemandOrderRecord[] {
    let result: EquipmentDemandOrderRecord[] = [];
    if (data && data.length > 0) {
      // iterate through each EDP and then transform it to EDO
      data.forEach(equip => {
        // read and assign the EDP level details
        const equipment: EquipmentRequest = new EquipmentRequest(equip);
        equipment.tcoReportParameters = this.generateTCOReportParameterString(equip);
        // if the EDP has any EDO then assing the values else if the EDO is not present the record wont be displayed on grid
        if (equip.equipmentDemandOrders) {
          // map the values from EDP/EDO to create a flattened record that is bound on grid at EDO level
          const demandOrders: EquipmentDemandOrder[] = equip.equipmentDemandOrders.map(ed => new EquipmentDemandOrder(ed, equipment));
          const demandOrderRecords: EquipmentDemandOrderRecord[] = demandOrders.map(ed => new EquipmentDemandOrderRecord(ed));
          // // if (this.gridModel.columns.find(s => s.field === 'EDOPriority')) {
          //   demandOrderRecords = this._edoEnrichmentService.setEDOEnrichmentData(demandOrderRecords);
          // }
          // append the record to existing list
          result = [...result, ...demandOrderRecords];
        }
      });
    }
    return result;
  }

  /**
   * On Activity Monitor Grid we have a column to generate Report against the each TCO Number
   * When User clicks on Report Icon under TCO Report Column certain set of parameters need to be provided
   * this method is used to generate the Parameters required for TCO report hyperlink
   * @private
   * @param {IEquipmentRequest} request
   * @returns {string}
   * @memberof ActivityMonitorGridComponent
   */
  private generateTCOReportParameterString(request: IEquipmentRequest): string {
    const productLinesId = Array.from(new Set(request.equipmentDemandOrders.map((item: any) => item.productLineId))).join(',');
    let siteId = '';
    this.userProfileViewModel.data.user.role.forEach(r => {
      const profile = r.profile.filter(p => p.workLocation === request.siteName);
      if (profile != null && profile.length > 0) {
        siteId = profile[0].siteDetails.sourceRecordId;
      }
    });
    const tcoReportUrl = '&paramSiteCode=' + request.siteName +
      '&paramSiteId=' + siteId +
      '&LOADOUT_ID=' + request.sourceRecordId +
      '&WHERE=WHERE STATUS NOT IN (\'CREATED\')&DISPLAYIMAGE=TRUE' +
      '&ProductLines=' + productLinesId;
    return tcoReportUrl;
  }
  //#endregion

  //#region Process the data based on the Grid State

  /**
   * This method processes the the activity monitor grid data based on the grid State
   * The grid state involves the Grouping, Filtering and Sort settings
   * @memberof ActivityMonitorGridComponent
   */
  processActivityMonitorData() {
    if (this.viewModel.activityMonitorGridData) {
      this.gridModel.GroupSettings.forEach(group => group.aggregates = this.aggregates);
      this.viewModel.activityMonitorBound = process(this.viewModel.activityMonitorGridData, this.gridModel.GridState);
      this._activitymonitorService.getPdfData(this.viewModel.activityMonitorGridData);
      this.gridModel.DataGridResult = this.viewModel.activityMonitorBound;
    }
    this.onDataLoadComplete();

    // Once the data is available the UOM conversions are triggered using below block
    if (this.userProfileViewModel && this.userProfileViewModel.data
      && this.userProfileViewModel.data.preference) {
      this._userProfileService.userPreferencesObservable.next(this.userProfileViewModel.data.preference);
    }
  }


  /**
   * This method checks if all the API requests are completed or not
   *  If no request is in-progress then it will fectch unique values for
   *  Client, Rig, Well, ProductLine and ProductGroup.
   *  This unique values will be used as source for respective columns under inline grid filters
   * @memberof ActivityMonitorGridComponent
   */
  onDataLoadComplete() {
    if (this.viewModel && this.viewModel.searchDataModel
      && !this.viewModel.searchDataModel.isDataFetchInProgress) {

      if (!this._edoEnrichmentService.isEnrihmentDataLoaded && this.sideNavModel.selectedLayout.layoutConfigs &&
        this.sideNavModel.selectedLayout.layoutConfigs.some(s => s.fieldName === ActivityMonitorConstant.customEDOPriorityFieldName)) {
        this.viewModel.activityMonitorGridData = this._edoEnrichmentService.setEDOEnrichmentData(this.viewModel.activityMonitorGridData,
          () => this.changeDetector.detectChanges());
      }

      this._loaderService.hideSpinner();
      this.viewModel.isSearchCollapsed = this.viewModel.data.allEquipmentDOData
        && this.viewModel.data.allEquipmentDOData.length > 0;
      this.viewModel.searchDataModel.MateoURLCollection = [];
      // #region Distinct Value Lists created for Grid Filters
      this.viewModel.clientFilterList =
        Array.from(new Set(this.viewModel.data.allEquipmentDOData.map(s => s.client).sort()));
      this.viewModel.rigFilterList =
        Array.from(new Set(this.viewModel.data.allEquipmentDOData.map(s => s.rig).sort()));
      this.viewModel.wellFilterList =
        Array.from(new Set(this.viewModel.data.allEquipmentDOData.map(s => s.well).sort()));
      this.viewModel.productGroupFilterList =
        Array.from(new Set(this.viewModel.data.allEquipmentDOData.map(s => s.productGroup).sort()));
      this.viewModel.productLineFilterList =
        Array.from(new Set(this.viewModel.data.allEquipmentDOData.map(s => s.productLine).sort()));
      this.viewModel.ToolNameFilterList =
        Array.from(new Set(this.viewModel.data.allEquipmentDOData.map(s => s.toolName).sort()));
      // #endregion
      if (this.viewModel.searchDataModel.isDataFetchFailed) {
        if (this.viewModel.searchModel.isAutoRefreshRequest) {
          this.ToasterServiceInstace.ShowError('Refresh Failed. Please try again later.', 'Refresh Failed');
          this.viewModel.searchModel.isAutoRefreshRequest = false;
        }
      }
      this.changeDetector.markForCheck();
    }
  }
  //#endregion

  /**
   * Fetch layouts saved in Database for Activity Monitor
   *
   * @memberof ActivityMonitorGridComponent
   */
  getActivityMonitorLayouts() {
    this.WriteDebugLog('ActivityMonitorComponent => getActivityMonitorLayouts');
    // API Call to get the layouts from Mongo Database
    this._columnOptionsService.getLayoutsforUserandApp(this.userProfileViewModel.data.user.ldapAlias,
      FMPConstant.activityMonitor).subscribe(response => {
        this.sideNavModel.LayoutsInContext = this.sideNavModel.data.ActivityMonitorLayouts;
        // if any past layout was marked as Active layout set it as current active layout
        let activeLayout = LO.find<Layout>(this.sideNavModel.data.ActivityMonitorLayouts,
          l => l.layoutID === response.activeLayouts.activeLayoutID);
        // if no previous layout was marked as Active then set the First layout within the list as Current Active layout
        activeLayout = activeLayout ? activeLayout : this.sideNavModel.data.ActivityMonitorLayouts[0];
        this.sideNavModel.selectedLayout = activeLayout;
        // trigger the Layout change in order to set the current active layout on grid
        this._columnOptionsService.triggerLayoutChange(this.sideNavModel.selectedLayout);
      }, error => this.WriteErrorLog('Error while fetching layouts for user.', error));
  }

  ngAfterViewInit() {
    this.WriteDebugLog('ActivityMonitorComponent => ngAfterViewInit');
    this.onResize(); // resize grid according to screen
    // get the master column list for Grid
    this.gridModel.columns = <ColumnComponent[]>this.activitymonitorgrid.columns.toArray();
    this.gridModel.DataGridInstance = this.activitymonitorgrid;
    this.changeDetector.detectChanges();
  }

  /**
   * This method is triggerd when the user changes layout selection
   *  The newly selected Layout is saved in Database as Active layout for the user
   * @param {*} event
   * @memberof ActivityMonitorGridComponent
   */
  onLayoutChange(event) {
    this.WriteDebugLog('ActivityMonitorComponent => onLayoutChange');
    const activeLayout: IActiveLayout = {
      activeLayoutID: this.sideNavModel.selectedLayout.layoutID,
      applicationName: FMPConstant.activityMonitor,
      userID: this.userProfileViewModel.data.user.ldapAlias
    };
    // Save the currently selected layout as active layout for user
    this._columnOptionsService.saveActiveLayout(activeLayout).subscribe(res => {
    }, error => this.WriteErrorLog('Error while saving active layout.', error));
    this._columnOptionsService.triggerLayoutChange(event);
  }

  /**
   * This method opens the Column Options panel
   *
   * @param {string} message
   * @memberof ActivityMonitorGridComponent
   */
  toOpenSideNavbar(message: string): void {
    this.WriteDebugLog('ActivityMonitorComponent => toOpenSideNavbar');
    document.getElementById('myColumnOptions').style.width = '300px';
    document.getElementById('columnOptionContextHelp').style.display = 'block';
    this.layoutDropdown.toggle(false);
    this.sideNavModel.application = FMPConstant.activityMonitor;
    this.sideNavModel.panelHeader = FMPConstant.activityMonitorPanel;
    this.sideNavModel.showColumnOptions = true;
    this.viewModel.isColumnOptionsOpening = true;
    this.sideNavModel.user = this.userProfileViewModel.data.user;
    this._columnOptionsService.triggerLayoutChange(this.sideNavModel.selectedLayout);
    this.onCDReAttach();
  }

  /**
   *  This method is called when there is any change w.r.t. grid
   *  Typically we manipulate the grid - pagination, groups, filters and sorting based on State object.
   * @param {DataStateChangeEvent} state
   * @memberof ActivityMonitorGridComponent
   */
  public dataStateChange(state: DataStateChangeEvent): void {
    this.onCDDetach();
    if (state) {
      if (state && state.group) {
        // If the Grouping is applied on more than 10 Groups then display a toaster message
        if (state.group.length > 10) {
          this.ToasterServiceInstace.ShowError('You can not group more than 10 columns');
          state.group.splice(state.group.length - 1, 1);
        }
        state.group.forEach(group => group.aggregates = this.aggregates);
      }
      this.gridModel.take = state.take;
      this.gridModel.skip = state.skip;
      this.gridModel.GroupSettings = state.group ? state.group.slice() : null;
      this.gridModel.SortSettings = state.sort ? state.sort.slice() : null;
      this.gridModel.FilterSettings = state.filter;
    }
    // Update the grid data based on Grid State
    this.processActivityMonitorData();
    if (this.expandCollapseGroups) {
      // The Expand/Collapse of groups on Grid is manipulated using pageChangeMaintainState()
      this.expandCollapseGroups.pageChangeMaintainState();
    }
    this.onCDReAttach();
  }

  /**
       * Manually Detaches the angular change detection.
       *
       * @memberof ActivitymonitorComponent
       */
  onCDDetach() {
    this.changeDetector.detach();
  }

  /**
   * Manually Re-attaches the angular change detection.
   *
   * @memberof ActivitymonitorComponent
   */
  onCDReAttach() {
    this.changeDetector.reattach();
    this.changeDetector.detectChanges();
  }

  public allData(): ExcelExportData {
    if (this.viewModel.activityMonitorGridData) {
      const result = process(this.viewModel.activityMonitorGridData, {
        filter: this.gridModel.FilterSettings,
        sort: this.gridModel.SortSettings,
      });
      return result;
    }
  }


  /**
   * This method is triggerd when the user changes the pagination
   *
   * @param {PageChangeEvent} pageChange
   * @memberof ActivityMonitorGridComponent
   */
  public pageChange(pageChange: PageChangeEvent): void {
    this.onCDDetach();
    this.gridModel.skip = pageChange.skip;
    this.gridModel.take = pageChange.take;
    this.processActivityMonitorData();
    if (this.expandCollapseGroups) {
      this.expandCollapseGroups.pageChangeMaintainState();
    }

    this.onResize();
    this.onCDReAttach();
  }


  /**
   * This method is used to manipulate the grid settings based on the layout selected
   * the list of columns is populated by comapring the field against the master list
   *
   * @memberof ActivityMonitorGridComponent
   */
  resetColumnsOrderBasedonLayout() {
    this.WriteDebugLog('ActivityMonitorComponent => resetColumnsOrderBasedonLayout');
    this.excelColumns = [];
    this.pdfColumns = [];
    this.totalWidth = 0;
    const newColumns: ColumnComponent[] = [];
    // push the first three default columns for Checkbox, Traffic light Icon and Data count
    newColumns.push(this.gridModel.columns[0]);
    newColumns.push(this.gridModel.columns[1]);
    newColumns.push(this.gridModel.columns[2]);
    this.pdfColumns.push(this.gridModel.columns[0]);
    this.pdfColumns.push(this.gridModel.columns[1]);

    this.sideNavModel.selectedLayout.layoutConfigs.forEach(lcol => {
      const columnFound: ColumnComponent = LO.find<ColumnComponent>(this.gridModel.columns,
        gcol => FMPHelper.StringEqual(gcol.field, lcol.fieldName));
      if (columnFound) {
        columnFound.locked = lcol.isLocked;
        columnFound.orderIndex = lcol.sequence;
        newColumns.push(columnFound);
        this.excelColumns.push(columnFound);
        if (exportExcelField.has(columnFound.field)) {
          this.excelColumns.push(exportExcelField.get(columnFound.field));
        }
        // PDF print can accomodate limited number of Columns considering the page size
        // Thus we add a column to Print PDF list by calculating the sum of widths of all selected columns
        // until the max width 1510 is reached
        // Thus we add a column to Print PDF list by calculating the sum of widths of all selected columns
        // untill the max width 1510 is reached
        this.totalWidth = this.totalWidth + columnFound.width;
        if (this.totalWidth <= 1510) {
          this.pdfColumns.push(columnFound);
        }
      }
    });
    const lockFixedCols = this.sideNavModel.selectedLayout.layoutConfigs.some(c => c.isLocked);
    // If atleast one column is locked then mark the first three columns as locked
    newColumns[0].locked = lockFixedCols; // Checkbox and Data count
    newColumns[1].locked = lockFixedCols; // Traffic light Icon
    newColumns[2].locked = lockFixedCols; // Data count - this column is hidden
    this.locking = lockFixedCols;
    // bind the newly genreated list of columns to grid
    this.activitymonitorgrid.columns.reset(newColumns);

    if (this.gridModel.GroupSettings) {
      this.gridModel.GroupSettings.forEach(group => group.aggregates = this.aggregates);
    }
    const currentGridState = this.gridModel.GridState;
    this.activitymonitorgrid.group = currentGridState.group;
    this.activitymonitorgrid.sort = currentGridState.sort;
    this.activitymonitorgrid.filter = currentGridState.filter;
    this.processActivityMonitorData();
    this._columnOptionsService.detectFilterChangesObservable.next(true);
    this.changeDetector.markForCheck();
  }

  /**
   * This method is used to set the grid height dynamically
   *
   * @memberof ActivityMonitorGridComponent
   */
  onResize() {
    const grid = $('#equipmentScreen');
    const tableH = grid.height();
    this.gridHeight = tableH - 55;
    this.changeDetector.markForCheck();
  }

  public onReorder(e: any): void {
    this.totalWidth = 0;
    this.pdfColumns = [];
    this.totalWidth = 0;
    const reorderedColumn = this.excelColumns.splice(e.oldIndex - 2, 1);
    this.excelColumns.splice(e.newIndex - 2, 0, ...reorderedColumn);
    this.excelColumns.forEach(element => {
      this.totalWidth = this.totalWidth + element.width;
      if (this.totalWidth <= 1510) {
        this.pdfColumns.push(element);
      }
    });
  }

  //#region  Dynamic CSS class

  /**
   * Defines a function that is executed for every data row in the component/grid
   * In this method we set the Row Level Traffic light Icons
   * @param {RowClassArgs} context
   * @returns
   * @memberof ActivityMonitorGridComponent
   */
  public rowCallback(context: RowClassArgs) {
    const objCSSClasses: any = {};

    if (context.dataItem.priority &&
      TrafficLightPriorityClass.has(context.dataItem.priority.toUpperCase())) {
      objCSSClasses[TrafficLightPriorityClass.get(context.dataItem.priority.toUpperCase())] = true;
    }

    if (context.dataItem.edoToolStatus.toUpperCase() !== TrafficLightStatus.shipped &&
      context.dataItem.edoToolStatus.toUpperCase() !== TrafficLightStatus.cancelled) {
      TrafficLightHelper.setDateClass(context.dataItem.plannedShipDate, objCSSClasses, ActivityMonitorConstant.planned);
      TrafficLightHelper.setDateClass(context.dataItem.nextShipDate,
        objCSSClasses, ActivityMonitorConstant.next);
      TrafficLightHelper.setDateClass(context.dataItem.tlmShipDate, objCSSClasses, ActivityMonitorConstant.tlm);
    }

    return objCSSClasses;
  }

  //#endregion

  /**
   * Angular life cycle hookup for NgDestory
   * UnSubscribe all the subscriptions
   * @memberof ActivityMonitorGridComponent
   */
  ngOnDestroy() {
    this.WriteDebugLog('Activity Monitor => ngOnDestroy');
    this.UnsubscribeObervable(this.layoutChangeSubscription);
    this.UnsubscribeObervable(this.equipmentRequestApiSubscription);
    this.UnsubscribeObervable(this.equipmentRequestTCOApiSubscription);
    this.UnsubscribeObervable(this.equipmentRequestErrorSubscription);
    this.UnsubscribeObervable(this.userPreferenceSubscription);
    this.UnsubscribeObervable(this.searchClickSubsciption);
    this.UnsubscribeObervable(this.patchTLMShipDateApiSubscription);
    this.UnsubscribeObervable(this.patchNextShipDateApiSubscription);
    this.UnsubscribeObervable(this.patchTLMAcualShipDateApiSubscription);
    this.UnsubscribeObervable(this.patchPriorityApiSubscription);
    this.UnsubscribeObervable(this.patchErrorSubscription);
  }

  /**
   *  This method triggers the Search, it will display a loader and then trigger FetchActivityMonitorData method
   * Fetch ActivityMonitorData will check if user has set any search params else it will load data based on site selections
   * @memberof ActivityMonitorGridComponent
   */
  ActivityMonitorSearchClickSubscription() {
    this.searchClickSubsciption = this._activitysearchService.searchChangeObservable.subscribe(search => {
      this.fetchActivityMonitorData();
      this.changeDetector.markForCheck();
    }, err => this.WriteErrorLog('Error occurred on search click.', err));
  }

  isRowSelected({ dataItem, index }): boolean {
    return dataItem.isChecked;
  }

  /**
 * Defines a function that is executed after row checkbox check
 * In this method triggers observable to check/uncheck grouplevel checkboxes
 * @param {value} boolean
 * @param {dataItem} EquipmentDemandOrderRecord
 * @returns
 * @memberof ActivityMonitorGridComponent
 */
  public rowCheckBoxChange(value: boolean, dataItem: EquipmentDemandOrderRecord) {
    dataItem.isChecked = value;
    this._componentInteractionService.groupCheckBoxObservable.next(value);
  }

  /**
   * Update the TLMActualShipDate for selected rows on AM Grid
   * @param {Date} updatedDate
   * @memberof ActivityMonitorGridComponent
   */
  public updateTlmActualShipDate(updatedDate: Date, dataItem: EquipmentDemandOrderRecord) {
    dataItem.isChecked = true;
    // this.updateSelectedRows(updatedDate, FMPConstant.tlmActualShipDate);
    this._mateoPatch.updateTLMActualShipDate(updatedDate, this.viewModel.activityMonitorGridData);
    this._componentInteractionService.groupCheckBoxObservable.next(true);
  }
  /**
   * Update the TLMShipDate for selected rows on AM Grid
   * @param {Date} updatedDate
   * @memberof ActivityMonitorGridComponent
   */

  public updateTlmShipDate(updatedDate: Date, dataItem: EquipmentDemandOrderRecord) {
    dataItem.isChecked = true;
    this._mateoPatch.updateTLMShipDate(updatedDate, this.viewModel.activityMonitorGridData);
    this._componentInteractionService.groupCheckBoxObservable.next(true);
  }
  /**
   * Update the PlannedShipDate for selected rows on AM Grid
   * @param {Date} updatedDate
   * @memberof ActivityMonitorGridComponent
   */
  public updatePlannedShipDate(updatedDate: Date, dataItem: EquipmentDemandOrderRecord) {
    dataItem.isChecked = true;
    this._mateoPatch.updatePlanShipDate(updatedDate, this.viewModel.activityMonitorGridData);
    this._componentInteractionService.groupCheckBoxObservable.next(true);
  }
  /**
   *Update the updateCustomPriority for selected rows on AM Grid
   *
   * @param {number} value
   * @param {EquipmentDemandOrderRecord} dataItem
   * @memberof ActivityMonitorGridComponent
   */
  public updateCustomPriority(value: any, dataItem: EquipmentDemandOrderRecord) {
    const edoEnrichmentList: EdoEnrichment[] = [];
    dataItem.isChecked = true;
    const equipmentDemandOrders = this.viewModel.activityMonitorGridData.filter(x => x.isChecked === true);

    equipmentDemandOrders.forEach(s => {
      let enrichmentData: EdoEnrichment;
      let edopriority: EDOPriority; enrichmentData = new EdoEnrichment();
      edopriority = new EDOPriority();
      enrichmentData.edoSourceRecordID = s.EDORecord.sourceRecordId;
      enrichmentData.site = s.siteName;
      edopriority.priority = value;
      edopriority.updatedBy = this._userProfileService.dataModel.user.ldapAlias;
      edopriority.updatedDate = String(new Date().toISOString());
      enrichmentData.edoPriority = edopriority;

      dataItem.EDOPriority = value;
      dataItem.EnrichmentData = enrichmentData;

      s.isChecked = true;
      s.EDORecord.isChecked = true;
      s.EDOPriority = value;
      s.EnrichmentData.edoPriority.priority = value;
      s.EnrichmentData.edoPriority.updatedBy = this._userProfileService.dataModel.user.ldapAlias;
      s.EnrichmentData.edoPriority.updatedDate = String(new Date().toISOString());
      edoEnrichmentList.push(enrichmentData);
    }
    );
    this._componentInteractionService.groupCheckBoxObservable.next(true);
    this._edoEnrichmentService.postEdoEnrichmentData(edoEnrichmentList).subscribe(edoEnrichData => {
    },
      error => {
        this.WriteErrorLog('Error in postEdoEnrichmentData subscribe', error);
      });
      this.changeDetector.detectChanges();
  }

  /**
   * Update the NextShipDate for selected rows on AM Grid
   * @param {Date} updatedDate
   * @memberof ActivityMonitorGridComponent
   */
  public updateNextShipDate(updatedDate: Date, dataItem: EquipmentDemandOrderRecord) {
    dataItem.isChecked = true;
    this.viewModel.rowUpdatedDate = updatedDate;
    this._mateoPatch.updateNextShipDate(updatedDate, this.viewModel.activityMonitorGridData);
    this._componentInteractionService.groupCheckBoxObservable.next(true);
  }

  public showCommentsPopup(dataItem: EquipmentDemandOrderRecord, columnName: string, maxLength: string) {
    const cmtVM: CommentPopupViewModel = new CommentPopupViewModel(dataItem = dataItem, columnName = columnName, maxLength = maxLength);
    this._componentInteractionService.commentPopupObservable.next(cmtVM);
  }

}
